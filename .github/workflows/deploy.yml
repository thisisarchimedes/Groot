name: Deploy Stage

on:
  workflow_dispatch:
  push:
    branches: [main]
    paths:
      - 'src/**'
      - 'scripts/**'
      - '.github/workflows/deploy.yml'

env:
  ENVIRONMENT: ${{ vars.DEFAULT_ENVIRONMENT }}
  DOTENV_KEY: ${{ secrets.DOTENV_KEY }}
  AWS_REGION: ${{ vars.AWS_REGION }}
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
  API_DEVOPS_EVENT_CATCHER: ${{ vars.API_DEVOPS_EVENT_CATCHER }}
  DEVOPS_EVENTS_SECRET_TOKEN: ${{ secrets.DEVOPS_EVENTS_SECRET_TOKEN }}
  EKS_REGION: ${{ vars.EKS_REGION }}
  ECR_REGISTRY: ${{ vars.ECR_REGISTRY }}
  ECR_REPO: ${{ vars.ECR_REPO }}

jobs:
  build:
    name: Build and Push Images
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'
          fetch-depth: 0

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install dotenvx
        run: |
          curl -fsS https://dotenvx.sh/ | sh

      - name: Install dependencies
        run: yarn install

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.EKS_REGION }}

      - name: Build and Push main Groot container
        run: |
          ./scripts/container_main_groot/build_main_groot_container.sh

          aws ecr get-login-password --region ${{ env.EKS_REGION }} | docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}
          docker tag groot-container:latest ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPO }}:groot-container
          docker push ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPO }}:groot-container

      - name: Build and push read node container
        run: |
          ./scripts/container_reader_node/build_read_node_container.sh
          
          aws ecr get-login-password --region ${{ env.EKS_REGION }} | docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}
          docker tag arch-production-node:latest ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPO }}:arch-production-node
          docker push ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPO }}:arch-production-node

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Deploy to EKS (DemoApp)
        run: |
          # Update kubeconfig
          aws eks update-kubeconfig --name groot-demo-app --region ${{ env.EKS_REGION }}
                    
          # Create the groot namespace if it doesn't exist
          kubectl create namespace groot --dry-run=client -o yaml | kubectl apply -f -
          
          # Create secrets
          kubectl apply -f - <<EOF
          apiVersion: v1
          kind: Secret
          metadata:
            name: aws-access-key-id
            namespace: groot
          type: Opaque
          stringData:
            AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          EOF
      
          kubectl apply -f - <<EOF
          apiVersion: v1
          kind: Secret
          metadata:
            name: aws-secret-access-key
            namespace: groot
          type: Opaque
          stringData:
            AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          EOF

          kubectl apply -f - <<EOF
          apiVersion: v1
          kind: Secret
          metadata:
            name: alchemy-api-key
            namespace: groot
          type: Opaque
          stringData:
            ALCHEMY_API_KEY: ${{ secrets.ALCHEMY_API_KEY }}
          EOF

          kubectl apply -f - <<EOF
          apiVersion: v1
          kind: Secret
          metadata:
            name: newrelic-api-key
            namespace: groot
          type: Opaque
          stringData:
            NEW_RELIC_API_KEY: ${{ secrets.NEW_RELIC_API_KEY }}
          EOF
          
          # Deploy or update Kubernetes manifests
          kubectl apply -f scripts/k8s/demoapp-configmap.yaml --namespace groot
          kubectl apply -f scripts/k8s/deployment.yaml --namespace groot
          kubectl apply -f scripts/k8s/service.yaml --namespace groot

          # Trigger a rolling restart of the deployment
          # kubectl rollout restart deployment/groot-deployment --namespace groot
                    
          # Verify deployment
          kubectl get pods --namespace groot
      
      - name: Setting Prometheus
        run: |
          #kubectl create namespace prometheus --dry-run=client -o yaml | kubectl apply -f -
          #helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          #helm repo update
          #helm upgrade --install prometheus prometheus-community/prometheus --namespace prometheus

          #kubectl apply -f scripts/k8s/prometheus-config.yaml --namespace prometheus

          #kubectl get pods --namespace prometheus

      - name: List all commit SHAs involved in the push
        id: format_commits
        shell: bash
        run: |
          ./devops/github_actions_templates/get_commit_shas.sh ${{ github.event.before }} ${{ github.event.after }} > commit_shas.txt
          COMMIT_SHAS_JSON=$(cat commit_shas.txt)
          echo "::set-output name=commit_shas::$COMMIT_SHAS_JSON"

      - name: Report DevOps Event
        run: |
          yarn add axios dotenv
          node devops/metrics/src/cicd_script/report_devops_event.js ${{ github.repository }} deploy '{"commit_ids": ${{ steps.format_commits.outputs.commit_shas }} }'

      - name: Slack Notification
        if: always()
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}